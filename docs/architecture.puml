@startuml Architecture Globale - Vue Simplifiée

!define RECTANGLE class

skinparam componentStyle rectangle
skinparam backgroundColor #FEFEFE
skinparam component {
    BackgroundColor<<presentation>> LightGreen
    BackgroundColor<<business>> LightBlue
    BackgroundColor<<data>> Orange
    BackgroundColor<<external>> Violet
}

package "Couche Présentation" <<presentation>> {
    [Next.js Frontend] as NEXTJS
    [Map Builder UI] as MAPUI
    [Driver Dashboard] as DRIVERUI
    [Client Dashboard] as CLIENTUI
}

package "Couche Métier" <<business>> {
    [Server Actions] as SA
    [FastAPI Service] as FASTAPI
    [Optimization Engine] as OPTIM
    [Supabase Auth] as AUTH
    [Supabase Realtime] as RT
}

package "Couche Données" <<data>> {
    database "PostgreSQL" as DB
    database "Redis Cache" as REDIS
    queue "MQTT Broker" as MQTT
    storage "Supabase Storage" as STORAGE
}

package "Services Externes" <<external>> {
    [Google OR-Tools] as ORTOOLS
    [Google Maps API] as MAPS
    [Twilio SMS] as SMS
    [SendGrid Email] as EMAIL
}

NEXTJS --> SA
MAPUI --> SA
DRIVERUI --> SA
CLIENTUI --> SA

NEXTJS --> AUTH
NEXTJS --> RT

SA --> DB
SA --> FASTAPI
SA --> STORAGE

FASTAPI --> OPTIM
OPTIM --> ORTOOLS
OPTIM --> DB

AUTH --> DB
RT --> DB

DB --> REDIS

DRIVERUI ..> MQTT : GPS Tracking
MQTT --> DB

FASTAPI --> MAPS
SA --> SMS
SA --> EMAIL

note right of ORTOOLS
  Résolution VRP/VRPTW
  Optimisation des tournées
end note

note right of MQTT
  Streaming GPS temps réel
  Protocol léger IoT
end note

note right of DB
  Row Level Security
  Multi-tenant isolation
end note

@enduml

@startuml Flux de Création de Mission

actor Dispatcher as D
participant "Map Builder\nUI" as UI
participant "Server\nAction" as SA
participant "PostgreSQL\nDatabase" as DB
participant "FastAPI\nOptimization" as API
participant "Google\nOR-Tools" as ORT

D -> UI : Ouvre Map Builder
activate UI

D -> UI : Ajoute sites sur carte
D -> UI : Ajoute items (colis)
D -> UI : Ajoute véhicules
D -> UI : Clique "Créer Mission"

UI -> SA : createMission(data)
activate SA

SA -> DB : INSERT missions, items, sites
activate DB
DB --> SA : mission_id
deactivate DB

SA --> UI : Mission créée
deactivate SA

D -> UI : Clique "Optimiser Route"

UI -> API : POST /api/optimize/route\n{locations, constraints}
activate API

API -> DB : SELECT sites, vehicles
activate DB
DB --> API : Données géographiques
deactivate DB

API -> API : Construit matrice distances\n(algorithme Haversine)

API -> ORT : Résoudre VRP/VRPTW
activate ORT
ORT -> ORT : Calcul route optimale
ORT --> API : Solution + métriques
deactivate ORT

API --> UI : Route optimisée\n{stops[], distance, duration}
deactivate API

UI -> SA : saveOptimizedRoute(route)
activate SA
SA -> DB : INSERT routes, route_stops
activate DB
DB --> SA : OK
deactivate DB
SA --> UI : Route sauvegardée
deactivate SA

UI --> D : Affiche route sur carte\navec polyline
deactivate UI

@enduml

@startuml Flux de Suivi GPS Temps Réel

actor Conducteur as DRV
participant "App Mobile" as APP
queue "MQTT\nBroker" as MQTT
participant "Backend\nService" as BACK
database "PostgreSQL" as DB
participant "Supabase\nRealtime" as RT
participant "Client Web" as CLIENT

DRV -> APP : Démarre mission
activate APP

APP -> BACK : updateMissionStatus(in_progress)
activate BACK
BACK -> DB : UPDATE missions SET status='in_progress'
activate DB
DB --> BACK : OK
deactivate DB
deactivate BACK

loop Toutes les 5 secondes
    APP -> APP : Capture position GPS
    APP -> MQTT : PUBLISH topic:\ntransport/vehicle/123/location\n{lat, lng, timestamp}
    activate MQTT

    MQTT -> BACK : Message GPS reçu
    activate BACK
    BACK -> DB : INSERT gps_locations
    activate DB
    BACK -> DB : UPDATE vehicles\nSET current_lat, current_lng
    DB --> BACK : OK
    deactivate DB

    DB -> RT : Changement détecté (trigger)
    activate RT
    RT -> CLIENT : WebSocket notification\n{vehicle_id, position}
    activate CLIENT
    CLIENT -> CLIENT : Met à jour marqueur carte
    CLIENT -> CLIENT : Recalcule ETA
    deactivate CLIENT
    deactivate RT
    deactivate BACK
    deactivate MQTT
end

DRV -> APP : Arrive à arrêt
DRV -> APP : Marque arrêt complété

APP -> BACK : completeStop(stop_id)
activate BACK
BACK -> DB : UPDATE route_stops\nSET status='completed',\nactual_arrival_time=NOW()
activate DB
DB --> BACK : OK
deactivate DB

DB -> RT : Notification changement
activate RT
RT -> CLIENT : Arrêt complété
activate CLIENT
CLIENT --> DRV : Notification confirmée
deactivate CLIENT
deactivate RT
deactivate BACK
deactivate APP

@enduml

@startuml Architecture de Déploiement

node "Internet" {
    actor Utilisateurs
    actor "Conducteurs\nMobile" as Drivers
}

cloud "CDN Cloudflare" {
    component [Assets Statiques] as CDN
}

cloud "Vercel Cloud" {
    component [Next.js\nServerless] as NEXT
    component [Edge Functions] as EDGE
}

cloud "Supabase Cloud" {
    component [Auth Service] as AUTH_SRV
    component [Database Service] as DB_SRV
    component [Realtime Service] as RT_SRV
    component [Storage Service] as STORAGE_SRV
    database "PostgreSQL 15" as PG
}

cloud "AWS / Cloud Server" {
    component [FastAPI\nContainer] as FAST
    component [MQTT Broker\nMosquitto] as MQTT_SRV
    database "Redis" as REDIS
}

cloud "Monitoring" {
    component [Sentry\nError Tracking] as SENTRY
    component [Analytics] as ANALYTICS
}

Utilisateurs --> CDN
Utilisateurs --> NEXT
Drivers --> NEXT

CDN --> NEXT
NEXT --> AUTH_SRV
NEXT --> DB_SRV
NEXT --> RT_SRV
NEXT --> FAST

AUTH_SRV --> PG
DB_SRV --> PG
RT_SRV --> PG

FAST --> DB_SRV
FAST --> REDIS

Drivers ..> MQTT_SRV : GPS Data
MQTT_SRV --> DB_SRV

NEXT --> SENTRY
NEXT --> ANALYTICS

note right of PG
  - Row Level Security
  - Multi-tenant isolation
  - Triggers & Functions
end note

note right of MQTT_SRV
  - Protocol MQTT 5.0
  - QoS level 1
  - Topics: transport/vehicle/{id}
end note

@enduml

@startuml Composants et Dépendances

package "Frontend Packages" {
    [app/web] as WEB
    [packages/ui] as UI
    [packages/features/auth] as FEAT_AUTH
    [packages/supabase] as PKG_SUPA
}

package "Backend Module" {
    [modules/transport] as TRANSPORT
}

package "Services Core" {
    component [Mission Service] as MISSION_SVC
    component [Route Service] as ROUTE_SVC
    component [Vehicle Service] as VEHICLE_SVC
    component [GPS Service] as GPS_SVC
    component [Notification Service] as NOTIF_SVC
}

package "Optimization" {
    component [VRP Solver] as VRP
    component [Distance Calculator] as DIST
    component [ETA Calculator] as ETA
}

package "Data Repositories" {
    component [Mission Repository] as MISSION_REPO
    component [Vehicle Repository] as VEHICLE_REPO
    component [GPS Repository] as GPS_REPO
}

WEB --> UI
WEB --> FEAT_AUTH
WEB --> PKG_SUPA

FEAT_AUTH --> PKG_SUPA

WEB --> MISSION_SVC
WEB --> ROUTE_SVC
WEB --> VEHICLE_SVC

TRANSPORT --> VRP

MISSION_SVC --> MISSION_REPO
ROUTE_SVC --> VRP
VEHICLE_SVC --> VEHICLE_REPO
GPS_SVC --> GPS_REPO

VRP --> DIST
VRP --> ETA

MISSION_SVC --> NOTIF_SVC
GPS_SVC --> NOTIF_SVC

MISSION_REPO --> PKG_SUPA
VEHICLE_REPO --> PKG_SUPA
GPS_REPO --> PKG_SUPA

@enduml

@startuml Modèle de Données Simplifié

entity "organizations" as ORG {
    * id : UUID <<PK>>
    --
    owner_id : UUID <<FK>>
    name : TEXT
    slug : TEXT <<UK>>
    status : TEXT
    created_at : TIMESTAMP
}

entity "organization_members" as MEMBERS {
    * id : UUID <<PK>>
    --
    organization_id : UUID <<FK>>
    user_id : UUID <<FK>>
    role : TEXT
    user_type : TEXT
    approved : BOOLEAN
}

entity "user_profiles" as PROFILES {
    * id : UUID <<PK>>
    --
    user_id : UUID <<FK>>
    organization_id : UUID <<FK>>
    display_name : TEXT
    user_type : TEXT
    phone : TEXT
}

entity "missions" as MISSIONS {
    * id : UUID <<PK>>
    --
    organization_id : UUID <<FK>>
    reference : TEXT <<UK>>
    status : TEXT
    driver_id : UUID <<FK>>
    vehicle_id : UUID <<FK>>
    scheduled_date : DATE
}

entity "routes" as ROUTES {
    * id : UUID <<PK>>
    --
    mission_id : UUID <<FK>>
    vehicle_id : UUID <<FK>>
    optimized_order : JSONB
    total_distance : DECIMAL
    status : TEXT
}

entity "route_stops" as STOPS {
    * id : UUID <<PK>>
    --
    route_id : UUID <<FK>>
    mission_id : UUID <<FK>>
    site_id : UUID <<FK>>
    sequence_order : INTEGER
    status : TEXT
}

entity "vehicles" as VEHICLES {
    * id : UUID <<PK>>
    --
    organization_id : UUID <<FK>>
    name : TEXT
    vehicle_type : TEXT
    capacity : DECIMAL
    current_latitude : DECIMAL
    current_longitude : DECIMAL
}

entity "sites" as SITES {
    * id : UUID <<PK>>
    --
    organization_id : UUID <<FK>>
    name : TEXT
    latitude : DECIMAL
    longitude : DECIMAL
    opening_hours : JSONB
}

entity "items" as ITEMS {
    * id : UUID <<PK>>
    --
    organization_id : UUID <<FK>>
    mission_id : UUID <<FK>>
    pickup_site_id : UUID <<FK>>
    delivery_site_id : UUID <<FK>>
    status : TEXT
}

entity "gps_locations" as GPS {
    * id : UUID <<PK>>
    --
    mission_id : UUID <<FK>>
    vehicle_id : UUID <<FK>>
    latitude : DECIMAL
    longitude : DECIMAL
    timestamp : TIMESTAMP
}

ORG ||--o{ MEMBERS
ORG ||--o{ PROFILES
ORG ||--o{ MISSIONS
ORG ||--o{ VEHICLES
ORG ||--o{ SITES
ORG ||--o{ ITEMS

MISSIONS ||--o{ ROUTES
MISSIONS ||--o{ STOPS
MISSIONS ||--o{ ITEMS
MISSIONS ||--o{ GPS

ROUTES ||--o{ STOPS

VEHICLES ||--o{ ROUTES
VEHICLES ||--o{ GPS

SITES ||--o{ STOPS
SITES ||--o{ ITEMS : pickup
SITES ||--o{ ITEMS : delivery

@enduml
